# RSA加密算法的直觀解釋！


# Key takeaway

1. RSA算法解決了什麼問題？

2. 為什麼黑客和公眾接收者都知道公鑰，但只有擁有私鑰的人才能解密加密訊息？

3. 什麼是歐拉定理，它與RSA有什麼關係？

4. 怎麼用群論，超簡單的理解歐拉定理? (optional)


# RSA 算法解決了什麼問題

小時候我們常常在課堂上傳遞小紙條，裡面常常寫著等下下課要去哪裡玩，班上的哪個女生特別可愛，老師上課好搞笑等等。但今天你的好朋友可能坐在離你很遠的地方，代表著傳遞這張小紙條的過程可能被路徑上的同學甲乙丙看到。那為了不要被他們知道你暗戀的女生是誰，你跟這個好朋友可以在下課的時候約定好一個暗號(加密/解密的過程)，這樣你們傳遞的小紙條就只有你們能夠知道裡面的內容了。但如果今天，你想傳遞紙條的朋友，在下課的時候忘記跟他約定暗號了，那該怎麼辦呢?

RSA算法解決了一個核心的密碼學問題：**如何在不安全的通信渠道上安全地傳輸加密密鑰**。在RSA出現之前，加密通信需要雙方事先共享一個秘密密鑰，這被稱為「對稱加密」。這種方法的主要問題是：如果欲傳遞對象沒有事先跟你接觸與做好約定，該如何安全地將這個密鑰傳給對方？

RSA作為第一個實用的「非對稱加密」算法，巧妙地解決了這個問題。它使用兩個不同但數學上相關的密鑰：
- 一個**公鑰**用於加密（可以公開分享）
- 一個**私鑰**用於解密（必須保密）
這種設計使得任何人都可以使用接收者的公鑰加密訊息，但只有擁有對應私鑰的接收者才能解密訊息，從而實現了無需預先共享秘密信息的安全通信。

接下來，我們會依據以下順序去直觀的介紹，RSA算法的核心!

1. [尋找規律！](RSA算法的直觀解釋.md)
2. [透過找到的規律，設計加密/解密過程！](RSA算法的直觀解釋.md)
3. [為什麼使用兩個大質數在設計這個算法中扮演關鍵角色？](RSA算法的直觀解釋.md)

## 1. 尋找規律！

在被複雜的符號搞得暈頭轉向之前，讓我們先看一些例子，並理解「為什麼對於任何數字 $N$，存在某個整數 $r$ 使得 $a^r\equiv1\pmod{N}$」。

### 1.1 如果 $N$ 是質數

設 $N=11$，我們可以觀測到以下現象：

$2^{10}\equiv1\pmod{11}$

$3^{10}\equiv1\pmod{11}$

$4^{10}\equiv1\pmod{11}$

...

$8^{10}\equiv1\pmod{11}$

$9^{10}\equiv1\pmod{11}$

$10^{10}\equiv1\pmod{11}$

且我們有：

$2^{10+1}\equiv2\pmod{11}$

$3^{10+1}\equiv3\pmod{11}$

...

$10^{10+1}\equiv10\pmod{11}$

將以上的觀測整理起來，我們會得到以下公式(如果 $N$ 是質數)：

1. $m^{N-1}\equiv1\pmod{N}$

以及

2. $m^{N}\equiv m\pmod{N}$

很神奇，對吧？

### 1.2 如果 $N=p*q$，其中 $p, q$ 都是不相等的質數

我們先陳述公式：

1. $m^{(p-1)(q-1)}\equiv1\pmod{N}$

以及

2. $m^{(p-1)(q-1) + 1}\equiv m\pmod{N}$

這個公式僅在 $gcd(m,N)\neq1$ 時不成立。

讓我們舉個例子：$p=5, q=7$，所以 $N=35$ 且 $(5-1)(7-1)=24$

$2^{(5-1)(7-1)}\equiv1\pmod{35}$

$3^{(5-1)(7-1)}\equiv1\pmod{35}$

$4^{(5-1)(7-1)}\equiv1\pmod{35}$

$5^{(5-1)(7-1)}\neq1\pmod{35}$

$6^{(5-1)(7-1)}\equiv1\pmod{35}$

$7^{(5-1)(7-1)}\neq1\pmod{35}$

$8^{(5-1)(7-1)}\equiv1\pmod{35}$

...

$14^{(5-1)(7-1)}\neq1\pmod{35}$

...

$34^{(5-1)(7-1)}\equiv1\pmod{35}$

且 

$2^{(5-1)(7-1)+1}\equiv2\pmod{35}$

$3^{(5-1)(7-1)+1}\equiv3\pmod{35}$

...

$34^{(5-1)(7-1)+1}\equiv34\pmod{35}$

### 1.3 （歐拉定理）如果 $N$ 是任何正整數：

我們先陳述公式：

1. $m^{\phi(N)}\equiv1\pmod{N}$

以及

2. $m^{\phi(N) + 1}\equiv m\pmod{N}$

其中 $\phi(N)$ 是小於 $N$ 且與 $N$ 互質的正整數的數量。

這就是著名的歐拉定理！

[理解歐拉定理](理解歐拉定理.md)

## 2. 通過觀察到的規律設計加密算法！

在觀察到這些規律之後，我們該如何應用這種規律性呢？

以下是我們要做的：

如果我們已經知道「所有小於質數 N 的正整數都有這個性質：$m^{N}\equiv m \mod{N}$」，那麼我們可以設計一個加密和解密過程，如下：

1. 我們將 $N$ 分成兩個正整數 $e, d$，其中 $d*e =(N-1)K+1$。我們要應用規則 $m^{d*e}=m^{(N-1)^K}*m\equiv m\pmod{N}$。我們發送 $(N,e)$ 作為公鑰，並將私鑰 $(N,d)$ 保密。（為簡單起見，可以視 $K=1$）
2. 加密：我們使用 $e$ 來加密訊息 $m$，計算 $m^e\pmod{N}$，然後我們得到加密後的訊息 $c=m^e\pmod{N}$
3. 解密：然後我們使用 $d$ 來解密加密訊息 $c$：$c^d\pmod{N}={m^{e}}^d\equiv m\pmod{N}$

所以我們將 $(N,e)$ 發送給他人用於加密，並保持 $(N,d)$ 私密用於解密。

然而，如果黑客截獲了公鑰 $(N,e)$ 並知道 $N$ 是質數，他們就會知道 $d*e = N$，所以 $d=N/e$。這樣你的私鑰 $(N,d)$ 就不再是私密的，加密訊息 $c$ 就可以被黑客解密。

因此，將 $N$ 設為質數不是個好主意。

## 我們能否設計一個算法，使得即使知道公鑰也無法揭示私鑰？

是的，我們可以！

我們結合兩個強大的觀察：

1. (1.2) 如果 $N=p*q$，其中 $p,q$ 都是質數且不相等，那麼 $\phi(N)=(p-1)(q-1)$
2. 計算 $p*q=N$ 很容易，但當 $N$ 相對較大時，找到 [$N=?*?$](https://en.wikipedia.org/wiki/Integer_factorization) 非常困難

所以如果我們選擇兩個不同的大質數 $p, q$ 並設 $N=p*q$，並設定兩個整數 $e$（加密），$d$（解密）使得：

1. $e*d=\phi(N)+1$ 

或

2. $e*d\equiv1\pmod{\phi(N)}$ （即 $e*d=\phi(N)*K+1$，其中 $K\in\mathbb{Z}$）

那麼我們就有以下性質：

$m^{e*d}=m^{\phi(N)*K+1}\equiv m\pmod{N}$

如果我們通過這個過程生成公鑰/私鑰，我們將得到：

1. 公鑰：$(N, e)$
2. 私鑰：$(N,d)$

而黑客只會獲得：

1. 公鑰：$(N,e)$

要找到私鑰 $d$，他們需要：

1. 進行整數因式分解，找到 $N=p*q$。（時間複雜度：$O(e^{c*(log{N}^{1/3})(log{log{N}}^{2/3})}$，當 $N$ 很大時，即使使用地球上最快的計算機也無法解決）
2. 找到 $\phi(N)=(p-1)(q-1)$
3. 找到 $d$ 使得 $e*d\equiv1\pmod{\phi(N)}$

但步驟 1 是不可行的，所以僅知道公鑰是不足以破解這個算法的，太神奇了！

到這一點，我們現在理解並能夠設計著名的 RSA 算法，正式陳述如下：

## RSA 算法：

1. 選擇任意質數 $p$、$q$，並計算 $N=p*q$
2. 設 $r=\phi(N)=\phi(p)\phi(q)=(p-1)(q-1)$
3. 選擇一個 $e\in\mathbb{Z}$，其中 $e<r$ 且 $gcd(e,r)=1$，並找到 $d\in\mathbb{Z}$ 使得 $ed\equiv1\pmod{r}$。
    
    即 $ed = r*K+1$，其中 $K\in\mathbb{Z}$
    
4. 銷毀 $p, q$

然後設置：

$(e, N)$：公鑰

$(d, N)$：私鑰

### 加密訊息 $m$：

我們使用公鑰 $(e, N)$ 將訊息 $m$ 加密為 $c$：

$c=m^e \pmod{N}$

### 解密加密的 $c$：

通過以下方式解密訊息：

$m=c^d \pmod{N}$

### 為什麼這有效？

我們只需要證明為什麼 $c^d\pmod{N}\equiv m$。

假設 $gcd(m, N)=1$，那麼：

1. $c^d\equiv m^{ed}\pmod{N}$
2. 由於 $ed=\phi(N)*K+1$，其中 $K\in\mathbb{Z}$
    
    我們有：$m^{ed}=m^{1+K*\phi(N)}=m*m^{\phi(N)^K}\equiv m\pmod{N}$
    
    注意：根據歐拉定理，$m^{\phi(N)}\equiv1\mod{N}$。
    

[為什麼設置 $N=p*q$，其中 $p, q$ 都是質數？](為什麼設置N為兩個質數的乘積.md) 